# 8.3 B-Tree 인덱스

B-Tree 는 데이터베이스 인덱싱 알고리즘 중 가장 일반적으로 사용되는 알고리즘이다. 
B-Tree 는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

### 8.3.1 구조 및 특성

B-Tree는 트리 구조의 최상위에 루트 노드가 존재 하고 그 하위에 자식 노드들이 붙어있는 형태이다.

트리 구조의 가장 하위에 있는 노드를 리프 노드라 하고 루트 노드와 리프 노드 사이에 있는 중간의 노드를 브랜치 노드라고 한다.

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

인덱스의 키 값은 모두 정렬되어 있으나 데이터 파일의 레코드는 정렬되어 있지 않다.

InnoDB에서는 인덱스를 통해 레코드를 읽을 때 바로 찾아가는 것이 아닌 인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색하고 프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제


#### 8.3.2.1 인덱스 키 추가

B-Tree에 값을 저장할 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.

저장될 위치가 정해지면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프노드에 저장한다.

만약 리프노드가 꽉 차서 저장할 공간이 없다면 리프 노드를 분리해야 하는데 이는 상위 브랜치 노드까지 작업 범위가 넓어진다. -> 쓰기 작업에 시간이 오래 걸림

InnoDB 같은 경우 인덱스 키 추가 작업을 지연시킬 수 있으나 프라이머리 키나 유니크 키는 중복체크가 필요하여 지연이 불가능하다.

#### 8.3.2.2 인덱스 키 삭제

해당 키 값이 저장된 B-Tree의 리프노드를 찾아서 삭제 마킹을 한다.

이때 마킹된 인덱스 키 공간은 방치되거나 재활용 될 수 있다.

이 작업 또한 디스크 I/O작업이 필요하다


#### 8.3.2.3 인덱스 키 변경

B-Tree의 키 값 변경은 먼저 해당 키 값 삭제 후, 다시 새로운 키 값을 추가하는 형식으로 진행된다. 

InnoDB에서는 체인지 버퍼를 통해 지연처리 될 수 있다.

#### 8.3.2.4 인덱스 키 검색

인덱스 검색은 루트 노드부터 최종 리프 노드까지 이동하면서 비교 작업을 수행한다(트리 탐색)
인덱스를 이용한 검색은 100%일치 혹은 값의 앞부분만 일치하는 경우에만 사용이 된다.

인덱스의 키값이 변형된 후 비교되는 경우에는 B-Tree의 빠른 검색 기능을 사용할 수 없다.(함수/연산 수행 후 인덱스 검색 x)

레코드 잠금, 넥스트 키 잠금은 검색을 수행한 인덱스를 잠근 후, 테이블의 레코드를 잠그는 방식으로 구현되어 있어 UPDATE, DELETE 시 적절한 인덱스가 없는 경우 모든 레코드를 잠궈야 하는 사태가 발생할 수 있다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

#### 8.3.3.1 인덱스 키 값 크기

InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본단위를 페이지(혹은 블록)라고 하며, 디스크의 모든 읽기/쓰기의 최소 작업 단위가 된다.

또한 버퍼 풀에서 데이터를 버퍼링하는 최소 단위가 되기도 한다.

인덱스 또한 페이지 단위로 관리되며, 루트, 브랜치, 리프노드를 구분하는 기준도 페이지이다.

Mysql에서 B-Tree의 자식 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 달려 있다.

인덱스를 구성하는 키 값의 크기가 커지면 페이지 내에 저장할 수 있는 키의 개수는 줄어들게 되고 결과적으로 디스크에 접근하는 횟수가 증가하여 성능이 감소한다.

#### 8.3.3.2 B-Tree의 깊이

인덱스의 키 값의 크기가 커지면 하나의 페이지에 담을 수 있는 인덱스 키 값의 개수가 줄어들게 되고, 같은 레코드 건수라 할지라도 깊이가 더 깊어지게 된다.

깊이기 깊어지면 디스크 읽기가 더 많이 필요하게 된다.

### 8.3.3.3 선택도(기수성)

모든 인덱스 키 값 가운데 유니크한 값의 개수를 의미한다.
(성별 같은 경우는 선택도가 2이고 주민등록번호같은 경우는 대한민국 내 인구 수 만큼...)

인덱스는 선택도가 높을수록 검색 대상이 줄어들어 성능이 좋아진다.

#### 8.3.3.4 읽어야 하는 레코드의 건수

일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드1건을 읽는 것이 테이블에서 직접 읽는 것보다 4~5 배 정도 비용이 든다고 판단한다.

즉 인덱스에서 읽어야 하는 데이터의 개수가 전체 테이블 레코드 개수의 20~25% 를 넘어서면 인덱스를 사용하지 않는 것이 더 이득이다.

### 8.3.4 B-Tree인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식이다.

루트 노드에서부터 비교를 하여 리프 노드까지 내려가야 필요한 레코드의 시작점을 알 수 있다.

일단 시작 지점을 찾으면 리프 노드는 레코드만 순서대로 스캔하면 된다.


#### 8.3.4.2 인덱스의 풀 스캔

인덱스의 처음부터 끝까지 모두 읽는 방식

대표적으로 쿼리의 조건절에서 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌경우 인덱스 풀 스캔 방식이 사용된다.

ex ) 인덱스가 A,B,C 칼럼의 순서로 만들어져 있으나 쿼리의 조건이 B,C 만 있는 경우

#### 8.3.4.3 루스 인덱스 스캔

듬성듬성 인덱스를 읽는 방법

중간에 필요하지 않은 인덱스 키값을 SKIP 하고 다음으로 넘어가는 방식으로 진행된다.

#### 8.3.4.4 인덱스 스킵 스캔

특정 칼럼 인덱스를 건너 뛰어 검색할 수 있는 방식